<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë²„ë¸” í„°ëœ¨ë¦¬ê¸°</title>
    <style>
        /* --- ê¸°ë³¸ ì„¤ì • --- */
        :root {
            --background-color: #0d0c1d;
            --card-color: #161a33;
            --text-color: #e5e5e5;
            --neon-blue: #00bfff;
            --neon-pink: #ff00ff;
            --neon-green: #39ff14;
            --neon-yellow: #fdfd96;
            
            --glow-blue: rgba(0, 191, 255, 0.7);
            --glow-pink: rgba(255, 0, 255, 0.7);
            --glow-green: rgba(57, 255, 20, 0.7);
            --glow-yellow: rgba(253, 253, 150, 0.7);
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: var(--background-color); /* Dark theme background */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            position: relative; /* For back button positioning */
            display: flex; /* Use flexbox to center content */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        canvas {
            display: block;
            background: linear-gradient(to bottom, var(--background-color), var(--card-color)); /* Dark theme gradient */
            position: absolute; /* Position canvas absolutely to allow description overlay */
            top: 0;
            left: 0;
            z-index: 1; /* Ensure canvas is behind the description when ready */
        }

        /* --- Back to Main Button --- */
        .back-to-main-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: var(--neon-blue);
            padding: 10px 15px;
            border-radius: 5px;
            text-decoration: none;
            font-weight: bold;
            font-size: 1rem;
            transition: all 0.2s ease;
            box-shadow: 0 0 8px var(--glow-blue);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .back-to-main-button:hover {
            background: var(--neon-blue);
            color: var(--background-color);
            box-shadow: 0 0 15px var(--glow-blue);
            transform: translateY(-2px);
        }

        .back-to-main-button .arrow-icon {
            font-size: 1.2em;
        }

        /* --- ë°˜ì‘í˜• ë””ìì¸ --- */
        @media (max-width: 768px) {
            .back-to-main-button {
                top: 10px;
                left: 10px;
                padding: 8px 12px;
                font-size: 0.9rem;
            }
        }

        /* --- Game Description --- */
        #gameDescription {
            position: absolute; /* Position it on top of the canvas */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            margin-top: 0; /* No margin top, centered with transform */
            padding: 25px;
            background: var(--card-color);
            border: 2px solid var(--neon-pink); /* Using neon-pink for highlight */
            border-radius: 15px;
            max-width: 500px;
            box-shadow: 0 0 15px var(--glow-pink); /* Using glow-pink */
            text-align: center; /* Center the text within the description box */
            z-index: 500; /* Ensure it's above the canvas but below back button */
            color: var(--text-color); /* Ensure description text color is set */
        }

        #gameDescription p {
            margin: 10px 0;
            font-size: 1rem;
            color: var(--text-color);
            line-height: 1.6;
            text-shadow: 0 0 3px rgba(255, 0, 255, 0.3); /* Using pink glow for text shadow */
        }

        #gameDescription p:first-child {
            font-weight: bold;
            font-size: 1.2rem;
            color: var(--neon-pink); /* Using neon-pink for title */
            text-shadow: 0 0 8px var(--glow-pink);
        }
    </style>
</head>
<body>
    <!-- ë©”ì¸ í˜ì´ì§€ë¡œ ëŒì•„ê°€ëŠ” ë²„íŠ¼ -->
    <a href="../../index.html" class="back-to-main-button">
        <span class="arrow-icon">&lt;</span> ë©”ì¸ìœ¼ë¡œ
    </a>

    <div id="gameDescription">
        <p>ğŸ«§ ìŠ¤íŠ¸ë ˆìŠ¤ í•´ì†Œ ë²„ë¸” í„°ëœ¨ë¦¬ê¸°</p>
        <p>ë– ì˜¤ë¥´ëŠ” ê±°í’ˆì„ í„°ëœ¨ë¦¬ë©° ë§ˆìŒì˜ í‰í™”ë¥¼ ì°¾ê³  ìŠ¤íŠ¸ë ˆìŠ¤ë¥¼ í•´ì†Œí•˜ì„¸ìš”!</p>
        <p>30ì´ˆ ì•ˆì— ìµœëŒ€í•œ ë§ì€ ë²„ë¸”ì„ í„°ëœ¨ë ¤ë³´ì„¸ìš”.</p>
        <button id="startButton" class="start-button">START</button>
    </div>

    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameDescription = document.getElementById('gameDescription'); // Get reference to description element
        const startButton = document.getElementById('startButton'); // Get reference to start button

        // Canvas í¬ê¸° ì„¤ì •
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ê²Œì„ ìƒíƒœ
        const STATE = {
            READY: 'READY',
            PLAYING: 'PLAYING',
            GAME_OVER: 'GAME_OVER'
        };

        // ê²Œì„ ë³€ìˆ˜
        let gameState = STATE.READY;
        let score = 0;
        let bubbles = [];
        let gameTime = 30;
        let startTime = 0;
        let lastBubbleTime = 0;
        let poppingBubbles = []; // í„°ì§€ëŠ” ì• ë‹ˆë©”ì´ì…˜ìš©

        // íŒŒìŠ¤í…” ìƒ‰ìƒ ë°°ì—´ (ìœ ì§€, ì–´ë‘ìš´ ë°°ê²½ì— ì˜ ë³´ì„)
        const pastelColors = [
            'rgba(255, 182, 193, 0.7)', // íŒŒìŠ¤í…” í•‘í¬
            'rgba(173, 216, 230, 0.7)', // íŒŒìŠ¤í…” ë¸”ë£¨
            'rgba(221, 160, 221, 0.7)', // íŒŒìŠ¤í…” í¼í”Œ
            'rgba(255, 218, 185, 0.7)', // íŒŒìŠ¤í…” ì˜¤ë Œì§€
            'rgba(152, 251, 152, 0.7)', // íŒŒìŠ¤í…” ê·¸ë¦°
            'rgba(255, 255, 153, 0.7)', // íŒŒìŠ¤í…” ì˜ë¡œìš°
            'rgba(255, 192, 203, 0.7)', // ë¼ì´íŠ¸ í•‘í¬
            'rgba(176, 224, 230, 0.7)'  // íŒŒìš°ë” ë¸”ë£¨
        ];

        // ê±°í’ˆ í´ë˜ìŠ¤
        class Bubble {
            constructor() {
                this.radius = Math.random() * 25 + 15; // 15 ~ 40px
                this.x = this.radius + Math.random() * (canvas.width - this.radius * 2);
                this.y = canvas.height + this.radius;
                this.speed = Math.random() * 2 + 1; // 1 ~ 3px
                this.color = pastelColors[Math.floor(Math.random() * pastelColors.length)];
            }

            update() {
                this.y -= this.speed;
            }

            draw() {
                // ê±°í’ˆ ê·¸ë¼ë°ì´ì…˜ íš¨ê³¼
                const gradient = ctx.createRadialGradient(
                    this.x - this.radius * 0.3,
                    this.y - this.radius * 0.3,
                    0,
                    this.x,
                    this.y,
                    this.radius
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(0.5, this.color);
                gradient.addColorStop(1, this.color.replace('0.7', '0.4'));

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // ê±°í’ˆ í…Œë‘ë¦¬
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // í•˜ì´ë¼ì´íŠ¸
                ctx.beginPath();
                ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fill();
            }

            isOffScreen() {
                return this.y + this.radius < 0;
            }

            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                // ì‘ì€ ë²„ë¸”ì˜ í´ë¦­ì„ ì‰½ê²Œ í•˜ê¸° ìœ„í•´ 10px ì—¬ìœ  ì¶”ê°€
                const hitRadius = this.radius + 10;
                return Math.sqrt(dx * dx + dy * dy) <= hitRadius;
            }
        }

        // í„°ì§€ëŠ” ê±°í’ˆ ì• ë‹ˆë©”ì´ì…˜ í´ë˜ìŠ¤
        class PoppingBubble {
            constructor(x, y, radius, color) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.maxRadius = radius * 1.5;
                this.alpha = 1;
                this.growSpeed = 3;
                this.fadeSpeed = 0.05;
            }

            update() {
                this.radius += this.growSpeed;
                this.alpha -= this.fadeSpeed;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.restore();
            }

            isDone() {
                return this.alpha <= 0;
            }
        }

        // ê²Œì„ ì´ˆê¸°í™”
        function initGame() {
            gameState = STATE.PLAYING;
            score = 0;
            bubbles = [];
            poppingBubbles = [];
            gameTime = 30;
            startTime = Date.now();
            lastBubbleTime = 0;
            gameDescription.style.display = 'none'; // Hide description when game starts
        }

        // ê±°í’ˆ ìƒì„±
        function createBubble(currentTime) {
            const interval = Math.random() * 700 + 500; // 500 ~ 1200ms
            if (currentTime - lastBubbleTime > interval) {
                bubbles.push(new Bubble());
                lastBubbleTime = currentTime;
            }
        }

        // í´ë¦­/í„°ì¹˜ ì´ë²¤íŠ¸ ì²˜ë¦¬
        function handleClick(x, y) {


            if (gameState === STATE.GAME_OVER) {
                gameState = STATE.READY;
                gameDescription.style.display = 'block'; // Show description to restart
                return;
            }

            if (gameState === STATE.PLAYING) {
                // ê±°í’ˆ í´ë¦­ í™•ì¸ (ë’¤ì—ì„œë¶€í„° í™•ì¸ - ìµœê·¼ ìƒì„±ëœ ê±°í’ˆ ìš°ì„ )
                for (let i = bubbles.length - 1; i >= 0; i--) {
                    if (bubbles[i].contains(x, y)) {
                        // í„°ì§€ëŠ” ì• ë‹ˆë©”ì´ì…˜ ì¶”ê°€
                        poppingBubbles.push(new PoppingBubble(
                            bubbles[i].x,
                            bubbles[i].y,
                            bubbles[i].radius,
                            bubbles[i].color
                        ));
                        bubbles.splice(i, 1);
                        score++;
                        break;
                    }
                }
            }
        }

        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            // CSS í¬ê¸°ì™€ ì‹¤ì œ ìº”ë²„ìŠ¤ í¬ê¸° ë¹„ìœ¨ ê³„ì‚°
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            handleClick(x, y);
        });

        // í„°ì¹˜ ì´ë²¤íŠ¸
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            // CSS í¬ê¸°ì™€ ì‹¤ì œ ìº”ë²„ìŠ¤ í¬ê¸° ë¹„ìœ¨ ê³„ì‚°
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            handleClick(x, y);
        });

        // Start ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
        startButton.addEventListener('click', () => {
            if (gameState === STATE.READY || gameState === STATE.GAME_OVER) {
                initGame();
            }
        });

        // UI ê·¸ë¦¬ê¸°
        function drawUI() {
            ctx.fillStyle = '#e5e5e5'; // Light text color
            ctx.font = 'bold 24px sans-serif';



            if (gameState === STATE.PLAYING) {
                ctx.textAlign = 'left';
                ctx.font = 'bold 28px sans-serif';
                ctx.fillText(`ì ìˆ˜: ${score}`, 20, 40);

                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const remaining = Math.max(0, gameTime - elapsed);
                ctx.textAlign = 'right';
                ctx.fillText(`ì‹œê°„: ${remaining}ì´ˆ`, canvas.width - 20, 40);

                // ì‹œê°„ ì¢…ë£Œ ì²´í¬
                if (remaining <= 0) {
                    gameState = STATE.GAME_OVER;
                }
            }

            if (gameState === STATE.GAME_OVER) {
                // ë°˜íˆ¬ëª… ì˜¤ë²„ë ˆì´
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // Darker semi-transparent overlay
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#e5e5e5'; // Light text color
                ctx.textAlign = 'center';
                ctx.font = 'bold 48px sans-serif';
                ctx.fillText('ê²Œì„ ì¢…ë£Œ!', canvas.width / 2, canvas.height / 2 - 60);
                ctx.font = 'bold 64px sans-serif';
                ctx.fillStyle = '#ff00ff'; // Neon pink for score
                ctx.fillText(`${score}ê°œ`, canvas.width / 2, canvas.height / 2 + 20);
                ctx.font = '24px sans-serif';
                ctx.fillStyle = '#aaa'; // Brighter informational text
                ctx.fillText('í´ë¦­í•˜ì—¬ ë‹¤ì‹œ ì‹œì‘', canvas.width / 2, canvas.height / 2 + 80);
            }
        }

        // ê²Œì„ ë£¨í”„
        function gameLoop() {
            // í™”ë©´ ì§€ìš°ê¸°
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const currentTime = Date.now();

            if (gameState === STATE.PLAYING) {
                // ê±°í’ˆ ìƒì„±
                createBubble(currentTime);

                // ê±°í’ˆ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
                for (let i = bubbles.length - 1; i >= 0; i--) {
                    bubbles[i].update();
                    bubbles[i].draw();

                    // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ê±°í’ˆ ì œê±°
                    if (bubbles[i].isOffScreen()) {
                        bubbles.splice(i, 1);
                    }
                }

                // í„°ì§€ëŠ” ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
                for (let i = poppingBubbles.length - 1; i >= 0; i--) {
                    poppingBubbles[i].update();
                    poppingBubbles[i].draw();

                    if (poppingBubbles[i].isDone()) {
                        poppingBubbles.splice(i, 1);
                    }
                }
            }

            // UI ê·¸ë¦¬ê¸°
            drawUI();

            requestAnimationFrame(gameLoop);
        }

        // ê²Œì„ ì‹œì‘
        gameLoop();
    </script>
</body>
</html>